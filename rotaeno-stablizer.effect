#define PI 3.14159265

uniform float4x4 ViewProj;
uniform texture2d image;

uniform float2 offset_s;
uniform float2 aspect_s;

sampler_state sp_linear
{
    Filter    = Linear;
    AddressU  = Border;
    AddressV  = Border;
    BorderColor = 00000000;
};

struct vertex_data
{
    float4 pos : POSITION;
    float2 uv  : TEXCOORD0;
};

vertex_data vertex_shader_main(vertex_data v_in)
{
    vertex_data v_out;
    v_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
    v_out.uv  = v_in.uv;
    return v_out;
}

float4 pixel_shader_main(vertex_data v_in) : TARGET
{
    float3 sTl = round(image.Sample(sp_linear, offset_s)).rgb;
    float3 sBr = round(image.Sample(sp_linear, float2(1,1)-offset_s)).rgb;
    float3 sTr = round(image.Sample(sp_linear, float2(1-offset_s.x,offset_s.y))).rgb;
    float3 sBl = round(image.Sample(sp_linear, float2(offset_s.x,1-offset_s.y))).rgb;
    float rtNum = dot(sTl, float3(2048,1024,512)) + dot(sTr, float3(256,128,64)) + dot(sBl, float3(32,16,8)) + dot(sBr, float3(4,2,1));
    float rotation = rtNum / 4096 * 2 * PI;

#ifdef _OPENGL
    mat2 mRotation = mat2(cos(rotation), sin(rotation), -sin(rotation), cos(rotation));
#else
    float2x2 mRotation = {cos(rotation), -sin(rotation), sin(rotation), cos(rotation)};
#endif

    float2 p_source = mul(mRotation, v_in.uv - 0.5) + 0.5;
    p_source = p_source * aspect_s;
    p_source = p_source + (1 - aspect_s) / 2;

    return image.Sample(sp_linear, p_source);
}

technique Draw
{
    pass
    {
        vertex_shader = vertex_shader_main(v_in);
        pixel_shader  = pixel_shader_main(v_in);
    }
}
